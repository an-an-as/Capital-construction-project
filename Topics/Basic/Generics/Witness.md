#### 从编译器的视角看泛型 
```swift
func min<T: Comparable>(_ x: T, _ y: T) -> T {
return y < x ? y : x
}
/// 中间层 -> 目击表(值、协议) -> 申请内存
/// 此时编译器并不知道参数具体大小和函数地址 通过中间层存放,如果超出中间层容量则在堆上申请内存并保存其引用
/// 泛型中的目击表被单独存储, 中间层相同类型的不同值可共享该目击表
/// 中间层的每个泛型参数关联一个目击表(值,协议),通过目击表的指针去申请内存操作值,如果只是简单的Int那就是简单的复制,如果是引用类型存在计数逻辑
/// 如果不存在协议目击表 那么 < 的实现函数就无法调用 即泛型和协议是紧密相连
```
min 的两个参数和返回值泛型的唯一约束是它们三者都必须是同样的类型 T，而这个 T 需要满足 Comparable。只要满足这个要求，T 可以是任意类型，它可以是 Int，Float，String 或者甚至是在编译时未知的定义在其他模块的某个类型。也就是说，编译器缺乏两个关键的信息，这导致它不能直接为这个函数生成代码:
1. 编译器不知道 (包括参数和返回值在内的) 类型为 T 的变量的大小
2. 编译器不知道需要调用的 < 函数是否有重载，因此也不知道需要调用的函数的地址。

**container 容器**
Swift 通过为泛型代码引入中间层来解决这些问题,当编译器遇到一个泛型类型的值时,它会将其包装到一个容器中,这个容器有固定的大小,并存储这个泛型值。如果这个值超过容器的尺寸，Swift 将在堆上申请内存，并将指向堆上该值的引用存储到容器中去。

**witness 目击表**
(值目击表 协议目击表 指向内存申请) -> 运行时函数动态派发到正确实现 
+ 对于每个泛型类型的参数，编译器还维护了一系列一个或者多个所谓的目击表 (witness table)
其中包含一个值目击表，以及类型上每个协议约束一个的协议目击表 这些目击表 (也被叫做 vtable) 将被用来将运行时的函数调用动态派发到正确的实现去
+ 对于任意的泛型类型，总会存在值目击表，它包含了指向内存申请，复制和释放这些类型的基本操作的指针。
这些操作对于像是 Int 这样的原始值类型来说，可能不需要额外操作，或者只是简单的内存复制，
不过对于引用类型来说，这里也会包含引用计数的逻辑。值目击表同时还记录了类型的大小和对齐方式。


这个例子中的泛型类型 T 将会包含一个协议目击表，因为 T 有 Comparable 这一个约束。对于这个协议声明的每个方法或者属性，协议目击表中都会含有一个指针，指向该满足协议的类型中的对应实现。
在泛型函数中对这些方法的每次调用，都会在运行时通过目击表中换为方法派发。在我们的例子中，y < x 这个表达式就是以这种方式进行派发的。


协议目击表提供了一组映射关系，通过这组映射，我们可以知道泛型类型满足的协议 (编译器通过泛型约束可以静态地知道这个信息) 和某个具体类型对于协议功能的具体实现 (这只在运行时才能知道) 的对应关系。
实际上，只有通过目击表我们才能查询或者操作某个值。我们无法在不加约束地定义一个 T 参数的同时，还期望它能对任意实现了 < 的类型工作。


如果没有满足 Comparable 的保证，编译器就不会让我们使用 < 操作，这是因为没有目击表可以让我们找到正确的 < 的实现。这就是我们说泛型和协议是紧密着联系的原因，
除了像是 Array< Element > 或者 Optional< Wrapped > 这样的容器类型，脱离了使用协议来约束泛型，泛型所能做的事情也就非常有限了。


泛型参数的容器结构和协议类型中使用的“存在容器” (existential containers) 有些相似，但是并不完全一样。
一个存在容器中不仅会有值的存储，还可能在一个结构体中存在指向目击表的指针。
而泛型参数的容器只会包含值存储，目击表是被单独存储的，这样泛型函数中同样类型的其他变量就可以共享这个目击表了。
```swift
func min<T: Comparable>(_ x: Box_T, _ y: Box_T, valueWTable_T: VTable, comparableWTable_T: VTable) -> Box_T {
let xCopy = valueWTable_T.copy(x)
let yCopy = valueWTable_T.copy(y)
let result = comparableWTable_T.lessThan(yCopy, xCopy) ? y : x
valueWTable_T.release(xCopy)
valueWTable_T.release(yCopy)
}
```
