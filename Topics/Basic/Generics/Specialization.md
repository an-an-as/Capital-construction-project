#### Generic specialization
泛型特化是指编译器按照具体的参数类型 (比如 Int)，将 min< T > 这样的泛型类型或者函数进行复制。
特化后的函数可以将针对 Int 进行特殊优化，移除所有的非直接因素。所以 min< T > 针对 Int 的特化版本是这样的：

```swift
func min(_ x: Int, _ y: Int) -> Int {
    return y < x ? y : x
}
```

这和自己实现的具体的非泛型 min 函数是完全一样的。泛型特化不仅能去掉虚拟派发的开销，还可以让像是内联等进一步优化成为可能。由于原来的函数是被非直接使用的，这些优化以前是无法实行的。优化器使用启发式的方法来决定需要为哪个泛型类型或函数进行特化操作，以及使用哪个具体类型进行特化。

即使编译器采取了非常激进的策略来进行泛型特化，如果这个泛型函数会被其他模块看到的话，该函数的泛型版本就将会始终存在。
在编译这些泛型函数的时候编译器并不知道外部的类型，保留泛型版本确保了外部代码始终可以调用到这个函数。

泛型特化只能在编译器可以看到泛型类型的全部定义以及想要进行特化的类型的时候才能生效。但是 Swift 编译器默认情况下是对源文件进行单独编译的，所以只有在使用泛型的代码和定义泛型代码在同一个文件中时，泛型特化才能工作。

因为这是一个很严重的限制，所以编译器引入了一个标志来启用全模块优化。在这个模式中，当前模块的所有文件会被当作全部都在一个文件中来进行优化，这让泛型特化可以横跨整个代码库进行工作

@_specialize 的非官方标签，它能让你将你的泛型代码进行指定版本的特化，使其在其他模块中也可用。你必须指明你想要进行特化的类型列表，所以这只在当你知道你的代码将如何被一些有限的类型使用的时候能有帮助。

注意我们将函数标记为了 public。为 internal、fileprivate 或者 private 的 API 添加 @_specialize 是没有意义的，因为它们对其他模块是不可见的。

```
@_specialize(exported: true, where T == Int)
@_specialize(exported: true, where T == String)
public func min<T: Comparable>(_ x: T, _ y: T) -> T {
return y < x ? y : x
}
```
